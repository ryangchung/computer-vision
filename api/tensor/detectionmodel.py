# -*- coding: utf-8 -*-
"""DetectionModel.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1irweoQWF4WUiT9CT_pHfzzs5qfTc9tYT

importing necessary libraries

We trained a model from scracth, used a pretrained model for better results as well
Used CNN (MobileNetV2 is built on CNN's) + our own layers
Data Collected ourself with Selenium Script in captureData.py
"""

from google.colab import drive, files
import tensorflow as tf
from tensorflow.keras import layers, models
from tensorflow.keras.applications import MobileNetV2
from tensorflow.keras.preprocessing.image import ImageDataGenerator
from tensorflow.keras.models import Sequential
from tensorflow.keras.layers import Conv2D, MaxPooling2D, Flatten, Dense, Dropout
from tensorflow.keras.utils import load_img, img_to_array
import numpy as np
import os

drive.mount('/content/drive')

train_datagen = ImageDataGenerator(rescale=1./255)
test_datagen = ImageDataGenerator(rescale=1./255)

test_dir = '/content/drive/My Drive/data/test'
train_dir = '/content/drive/My Drive/data/train'

train_data = train_datagen.flow_from_directory(
    train_dir ,
    target_size=(128, 128), 
    batch_size=32,        
    class_mode='binary'     # Binary because we have (productive/unproductive)
)

test_data = test_datagen.flow_from_directory(
    test_dir,
    target_size=(128, 128),
    batch_size=32,
    class_mode='binary'
)

base_model = tf.keras.applications.MobileNetV2(
    input_shape=(128, 128, 3),
    include_top=False,         # Exclude final classification layers, we want our own
    weights='imagenet'         # Use pretrained weights from ImageNet
)

# Freeze the base model
base_model.trainable = False

model = tf.keras.Sequential([
    base_model,
    tf.keras.layers.GlobalAveragePooling2D(),
    tf.keras.layers.Dense(128, activation='relu'),
    tf.keras.layers.Dropout(0.3),
    tf.keras.layers.Dense(1, activation='sigmoid')
])

model.compile(optimizer='adam',
              loss='binary_crossentropy',
              metrics=['accuracy'])

model.summary()

history = model.fit(
    train_data,
    validation_data=test_data,
    epochs=10
)

uploaded_image = files.upload()
image_path = next(iter(uploaded_image))  # Get the path of the uploaded image

# Load and preprocess the image
img = load_img(image_path, target_size=(128, 128))
img_array = img_to_array(img) / 255.0
img_array = np.expand_dims(img_array, axis=0)

prediction = model.predict(img_array)
print("Prediction:", "Productive" if prediction[0][0] < 0.5 else "Unproductive")

model.save('model.h5')
